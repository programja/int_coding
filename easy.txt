Answers in Java
Problem definitions above solution, will notify when sub- or optimal per performance/space.
Per how to approach:

Start with easy problems (maybe one month, 20 - 30 problems, top-100 liked/interview questions);
Per interviews: Stick to medium
Best ones - Top 100 liked problems;
Start with easy -> hard DS (arrays, stack, queue -> heaps);
Dont spend in one problem hours and hours, look at the solution

Create a repo for the solutions: https://github.com/programja/int_coding

Will do 50 of 100 Liked questions
Will do 50 of 100 Interview questions

LIKED:

1. Problem definition: Two Sum 10/18
Given: Array of integers and an integer target, return indices of the two numbers such that they add up to target.
One solution, cannot use the same element twice.

Solution:
A) Could be quicker.

class Solution {
    public int[] twoSum(int[] nums, int target) {

        int nLength = nums.length;
        int[] ansArray = new int[2];

        for (int i=0; i < nLength; i++) {
            for (int j = i+1; j < nLength; j++) {
                if (nums[i] + nums[j] == target) {
                    ansArray[0] = i;
                    ansArray[1] = j;
                }
            }
        }

        return ansArray;
    }
}

2. Problem definition: Merge Two Sorted Lists 10/20
Merge two sorted lists and return it as a sorted list.
The list should be made by splicing together the nodes of the first two lists.

Data Structure: ListNode [Java LinkedLists]

Problem I am having is understanding how to deal with ListNodes.
Very little documentation that works.

Solution: DOES NOT WORK YET

class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {

        ListNode l3 = new ListNode();

        if(l1 == null || l1.next == null || l2 == null || l2.next == null) {
            return null;
        }

        if (l1 != null && l2 == null) {
            return ((int) l1.val);
        } else if (l1 == null && l2 != null) {
            return ((int) l2.val);
        }

        while (l1 != null && l2 != null) {
            if (l1.val < l2.val) {
                l3.val = l1.val;
                l3 = l3.next;
                l1 = l1.next;
            } else {
                l3.val = l2.val;
                l3 = l3.next;
                l2 = l2.next;
            }
        }
        return l3;
    }
}



3. Problem definition:

Solution:

4. Problem definition:

Solution:

5. Problem definition:

Solution:

6. Problem definition:

Solution:
